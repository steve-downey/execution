<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beman::execution: overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
 <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
 <script type="text/javascript">
     DoxygenAwesomeDarkModeToggle.init()
 </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="beman-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">beman::execution
   </div>
   <div id="projectbrief">Building Block For Asynchronous Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md2"></a>
std::execution Overview</h1>
<p>This page provides an overview of the components in <code>std::execution</code>. The documentation on this page doesn’t represent all details of the specification. However, it should capture enough details to be a suitable resource to determine how the various components are used.</p>
<p>For each of the components a summary view is provided. To get more details expand the respective section. </p>
<h2><a class="anchor" id="autotoc_md3"></a>
Terms</h2>
<p>This section defines a few terms used throughout the description on this page. The terms aren’t taken from the specification and are, thus, somewhat informal.</p>
<details >
<summary >
completion signal</summary>
<p>When an asynchronous operation completes it <em>signals</em> its completion by calling a completion function on a <code><a href="‘#receiver’">receiver</a></code>:</p>
<ul>
<li><code><a href="‘#set-value’">std::execution::set_value</a>(<em>receiver</em>, <em>args</em>...)</code> is called when an operation completes successfully. A call to this completion function is referred to as <em>value completion signal</em>.</li>
<li><code><a href="‘#set-error’">std::execution::set_error</a>(<em>receiver</em>, <em>error</em>)</code> is called when an operation fails to deliver its success results. A call to this completion function is referred to as <em>error completion signal</em>.</li>
<li><code><a href="‘#set-stopped’">std::execution::set_stopped</a>()</code> is called when an operation was cancelled. A call to this completion function is referred to as <em>cancellation completion signal</em>.</li>
<li>Collectively the value, error, and cancellation completion signals are referred to as <em>completion signal</em>. Note that any <code><a href="‘#start’">start</a></code>ed asynchronous operation triggers exactly one completion signal. </li>
</ul>
</details>
<details >
<summary >
environment</summary>
<p>The term <em>enviroment</em> refers to the bag of properties associated with an <code><em>object</em></code> by the call <code><a href="‘#get-env’">std::execution::get_env</a>(<em>object</em>)</code>. By default the environment for objects is empty (<code><a href="‘#empty-env’">std::execution::empty_env</a></code>). In particular, environments associated with <code><a href="‘#receiver’">receiver</a></code>s are used to provide access to properties like the <a href="‘#get-stop-token’">stop token</a>, <a href="‘#get-scheduler’">scheduler</a>, or <a href="‘#get-allocator’">allocator</a> associated with the <code><a href="‘#receiver’">receiver</a></code>. The various properties associated with an object are accessed via <a href="‘#queries’">queries</a>. </p>
</details>
<h2><a class="anchor" id="autotoc_md4"></a>
Concepts</h2>
<p>This section lists the concepts from <code>std::execution</code>.</p>
<details >
<summary >
<code>operation_state&lt;<em>State</em>&gt;</code></summary>
<p></p>
<p>Operation states represent asynchronous operations ready to be <code><a href="‘#start’">start</a></code>ed or executing. Operation state objects are normally neither movable nor copyable. Once <code><a href="‘#start’">start</a></code>ed the object needs to be kept alive until a <a href="‘#completion-signal’">completion signal</a> is received. Users don’t interact with operation states explicitly except when implementing new sender algorithms.</p>
<p>Required members for <code><em>State</em></code>:</p>
<ul>
<li>The type <code>operation_state_concept</code> is an alias for <code>operation_state_t</code> or a type derived thereof.</li>
<li><code><em>state</em>.<a href="‘#start’">start</a>() &amp; noexcept</code></li>
</ul>
<details >
<summary >
Example</summary>
<p></p>
<p>This example shows a simple operation state object which immediately completes successfully without any values (as <code><a href="‘#just’"></a>()</code> would do). Normally <code><a href="‘#start’">start</a>()</code> initiates an asynchronous operation completing at some point later.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">struct example_state</div>
<div class="line">{</div>
<div class="line">    using operation_state_concept = std::execution::operation_state_t;</div>
<div class="line">    std::remove_cvref_t&lt;Receiver&gt; receiver;</div>
<div class="line"> </div>
<div class="line">    auto start() &amp; noexcept {</div>
<div class="line">        std::execution::set_value(std::move(this-&gt;receiver));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::execution::operation_state&lt;example_state&lt;SomeReceiver&gt;&gt;);</div>
</div><!-- fragment --> </details>
</details>
<details >
<summary >
<code>receiver&lt;<em>Receiver</em>&gt;</code></summary>
<p></p>
<p>Receivers are used to receive <a href="‘#completion-signal’">completion signals</a>: when an asynchronous operation completes the corresponding <a href="‘#completion-signal’">completion signal</a> is called with the appropriate arguments. In addition receivers provide access to the <a href="‘#environment’">environment</a> for the operation via the <a href="‘#get-env’"><code>get_env</code></a> method. Users don’t interact with receivers explicitly except when implementing new sender algorithms.</p>
<p>Required members for <code><em>Receiver</em></code>:</p>
<ul>
<li>The type <code>receiver_concept</code> is an alias for <code>receiver_t</code> or a type derived thereof`.</li>
<li>Rvalues of type <code><em>Receiver</em></code> are movable.</li>
<li>Lvalues of type <code><em>Receiver</em></code> are copyable.</li>
<li><code><a href="‘#get-env’">std::execution::get_env</a>(<em>receiver</em>)</code> returns an object. By default this operation returns <code><a href="‘empty-env’">std::execution::empty_env</a></code>.</li>
</ul>
<p>Typical members for <code><em>Receiver</em></code>:</p>
<ul>
<li><code><a href="‘get_env’">get_env</a>() const noexcept</code></li>
<li><code><a href="‘set_value’">set_value</a>(args…) &amp;&amp; noexcept -&gt; void</code></li>
<li><code><a href="‘set_error’">set_error</a>(error) &amp;&amp; noexcept -&gt; void</code></li>
<li><code><a href="‘set_stopped’">set_stopped</a>() &amp;&amp; noexcept -&gt; void</code></li>
</ul>
<details >
<summary >
Example</summary>
<p></p>
<p>The example receiver prints the name of each the received <a href="‘#completion-signal’">completion signal</a> before forwarding it to a receiver. It forwards the request for an environment (<code><a href="‘#get_env’">get_env</a></code>) to the nested receiver. This example is resembling a receiver as it would be used by a sender injecting logging of received signals.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template &lt;std::execution::receiver NestedReceiver&gt;</div>
<div class="line">struct example_receiver</div>
<div class="line">{</div>
<div class="line">    using receiver_concept = std::execution::receiver_t;</div>
<div class="line">    std::remove_cvref_t&lt;NestedReceiver&gt; nested;</div>
<div class="line"> </div>
<div class="line">    auto get_env() const noexcept {</div>
<div class="line">        return std::execution::get_env(this-&gt;nested);</div>
<div class="line">    }</div>
<div class="line">    template &lt;typename… A&gt;</div>
<div class="line">    auto set_value(A&amp;&amp;… a) &amp;&amp; noexcept -&gt; void {</div>
<div class="line">        std::cout &lt;&lt; “set_value\n”;</div>
<div class="line">        std::execution::set_value(std::move(this-&gt;nested), std::forward&lt;A&gt;(a)…);</div>
<div class="line">    }</div>
<div class="line">    template &lt;typename E&gt;</div>
<div class="line">    auto set_error(E&amp;&amp; e) &amp;&amp; noexcept -&gt; void {</div>
<div class="line">        std::cout &lt;&lt; “set_error\n”;</div>
<div class="line">        std::execution::set_error(std::move(this-&gt;nested), std::forward&lt;E&gt;(e));</div>
<div class="line">    }</div>
<div class="line">    auto set_stopped() &amp;&amp; noexcept -&gt; void {</div>
<div class="line">        std::cout &lt;&lt; “set_stopped\n”;</div>
<div class="line">        std::execution::set_stopped(std::move(this-&gt;nested));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::execution::receiver&lt;example_receiver&lt;SomeReceiver&gt;&gt;);</div>
</div><!-- fragment --> </details>
</details>
<details >
<summary >
<code>receiver_of&lt;<em>Receiver, Completions</em>&gt;</code></summary>
<p></p>
<p>The concept <code>receiver_of&lt;<em>Receiver, Completions</em>&gt;</code> tests whether <code><a href="‘#receiver’">std::execution::receiver</a>&lt;<em>Receiver</em>&gt;</code> is true and if an object of type <code><em>Receiver</em></code> can be invoked with each of the <a href="‘#completion-signal’">completion signals</a> in <code><em>Completions</em></code>.</p>
<details >
<summary >
Example</summary>
<p></p>
<p>The example defines a simple <code><a href="‘#receiver’">receiver</a></code> and tests whether it models <code>receiver_of</code> with different <a href="‘#completion-signal’">completion signals</a> in <code><em>Completions</em></code> (note that not all cases are true).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct example_receiver</div>
<div class="line">{</div>
<div class="line">    using receiver_concept = std::execution::receiver_t;</div>
<div class="line"> </div>
<div class="line">    auto set_value(int) &amp;&amp; noexcept -&gt;void {}</div>
<div class="line">    auto set_stopped() &amp;&amp; noexcept -&gt;void {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">// matching the exact signals models receiver_of:</div>
<div class="line">static_assert(std::execution::receiver_of&lt;example_receiver,</div>
<div class="line">    std::execution::completion_signals&lt;</div>
<div class="line">        std::execution::set_value_t(int),</div>
<div class="line">        std::execution::set_stopped_t()</div>
<div class="line">    &gt;);</div>
<div class="line">// providing a superset of signal models models receiver_of:</div>
<div class="line">static_assert(std::execution::receiver_of&lt;example_receiver,</div>
<div class="line">    std::execution::completion_signals&lt;</div>
<div class="line">        std::execution::set_value_t(int)</div>
<div class="line">    &gt;);</div>
<div class="line">// providing only a subset of signals doesn’t model receiver_of:</div>
<div class="line">static_assert(not std::execution::receiver_of&lt;example_receiver,</div>
<div class="line">    std::execution::completion_signals&lt;</div>
<div class="line">        std::execution::set_value_t(),</div>
<div class="line">        std::execution::set_value_t(int)</div>
<div class="line">    &gt;);</div>
</div><!-- fragment --> </details>
</details>
<details >
<summary >
<code>scheduler&lt;<em>Scheduler</em>&gt;</code></summary>
<p>Schedulers are used to specify the execution context where the asynchronous work is to be executed. A scheduler is a lightweight handle providing a <code><a href="‘#schedule’">schedule</a></code> operation yielding a <code><a href="‘sender’">sender</a></code> with a value <a href="‘#completion-signal’">completion signal</a> without parameters. The completion is on the respective execution context.</p>
<p>Requirements for <code><em>Scheduler</em></code>:</p><ul>
<li>The type <code><em>Scheduler</em>::scheduler_concept</code> is an alias for <code>scheduler_t</code> or a type derived thereof.</li>
<li><code><a href="‘#schedule’">schedule</a>(<em>scheduler</em>) -&gt; <a href="‘sender’">sender</a></code></li>
<li>The <a href="‘#get-completion-scheduler’">value completion scheduler</a> of the <code><a href="‘sender’">sender</a></code>’s <a href="‘#environment’">environment</a> is the <code><em>scheduler</em></code>: <em>scheduler</em> == std::execution::get_completion_scheduler&lt;std::execution::set_value_t&gt;( std::execution::get_env(std::execution::schedule(<em>scheduler</em>)) )</li>
<li><code>std::equality_comparable&lt;<em>Scheduler</em>&gt;</code></li>
<li><code>std::copy_constructible&lt;<em>Scheduler</em>&gt;</code> </li>
</ul>
</details>
<details >
<summary >
<code>sender&lt;<em>Sender</em>&gt;</code></summary>
<p></p>
<p>Senders represent asynchronous work. They may get composed from multiple senders to model a workflow. Senders can’t be run directly. Instead, they are passed to a &lt;a href=‘::sender-consumer’ which <code><a href="‘#connect’">connect</a></code>s the sender to a <code><a href="‘#receiver’">receiver</a></code> to produce an <code><a href="‘#operation-state’">operation_state</a></code> which may get started. When using senders to represent work the inner workings shouldn’t matter. They do become relevant when creating sender algorithms.</p>
<p>Requirements for <code><em>Sender</em></code>:</p><ul>
<li>The type <code><em>Sender</em>::sender_concept</code> is an alias for <code>sender_t</code> or a type derived thereof or <code><em>Sender</em></code> is a suitable <em>awaitable</em>.</li>
<li><code><a href="get_env">std::execution::get_env</a>(<em>sender</em>)</code> is valid. By default this operation returns <code><a href="‘empty-env’">std::execution::empty_env</a></code>.</li>
<li>Rvalues of type <code><em>Sender</em></code> can be moved.</li>
<li>Lvalues of type <code><em>Sender</em></code> can be copied.</li>
</ul>
<p>Typical members for <code><em>Sender</em></code>:</p><ul>
<li><code><a href="‘get_env’">get_env</a>() const noexcept</code></li>
<li><code><a href="‘get_completion_signatures’">get_completion_signatures</a>(<em>env</em>) const noexcept -&gt; <a href="‘completion-signatures’">std::execution::completion_signatures</a>&lt;...&gt;</code></li>
<li><code><em>Sender</em>::completion_signatures</code> is a type alias for <code><a href="‘completion-signatures’">std::execution::completion_signatures</a>&lt;...&gt;</code> (if there is no <code><a href="‘get_completion_signatures’">get_completion_signatures</a></code> member).</li>
<li><code><a href="‘#connect’">connect</a>(<em>sender</em>, <a href="‘#receiver’">receiver</a>) -&gt; <a href="‘#operation-state’">operation_state</a></code></li>
</ul>
<details >
<summary >
Example</summary>
<p>The example shows a sender implementing an operation similar to <code><a href="‘#just’">just</a>(_value)</code>.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct example_sender</div>
<div class="line">{</div>
<div class="line">    template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">    struct state</div>
<div class="line">    {</div>
<div class="line">        using operation_state_concept = std::execution::operation_state_t;</div>
<div class="line">        std::remove_cvref_t&lt;Receiver&gt; receiver;</div>
<div class="line">        int                           value;</div>
<div class="line">        auto start() &amp; noexcept {</div>
<div class="line">            std::execution::set_value(</div>
<div class="line">                std::move(this-&gt;receiver),</div>
<div class="line">                this-&gt;value</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    using sender_concept = std::execution::sender_t;</div>
<div class="line">    using completion_signatures = std::execution::completion_signatures&lt;</div>
<div class="line">        std::execution::set_value_t(int)</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">    int value{};</div>
<div class="line">    template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">    auto connect(Receiver&amp;&amp; receiver) const -&gt; state&lt;Receiver&gt; {</div>
<div class="line">        return { std::forward&lt;Receiver&gt;(receiver), this-&gt;value };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::execution::sender&lt;example_sender&gt;);</div>
</div><!-- fragment --> </details>
</details>
<details >
<summary >
<code>sender_in&lt;<em>Sender, Env</em> = std::execution::empty_env&gt;</code></summary>
<p></p>
<p>The concept <code>sender_in&lt;<em>Sender, Env</em>&gt;</code> tests whether <code><em>Sender</em></code> is a <code><a href="‘#sender’">sender</a></code>, <code><em>Env</em></code> is a destructible type, and <code><a href="‘#get_completion_signatures’">std::execution::get_completion_signatures</a>(<em>sender</em>, <em>env</em>)</code> yields a specialization of <code><a href="‘#completion_signatures’">std::execution::completion_signatures</a></code>. </p>
</details>
<details >
<summary >
<code>sender_to&lt;<em>Sender, Receiver</em>&gt;</code></summary>
<p></p>
<p>The concept <code>sender_to&lt;<em>Sender, Receiver</em>&gt;</code> tests if <code><a href="‘#sender_in’">std::execution::sender_in</a>&lt;<em>Sender</em>, <a href="#env_of_t">std::execution::env_of_t</a>&lt;<em>Receiver</em>&gt;&gt;</code> is true, and if <code><em>Receiver</em></code> can receive all <a href="‘#completion-signals’">completion signals</a> which can be sent by <code><em>Sender</em></code>, and if <code><em>Sender</em></code> can be <code><a href="‘#connect’">connect</a></code>ed to <code><em>Receiver</em></code>.</p>
<p>To determine if <code><em>Receiver</em></code> can receive all <a href="‘#completion-signals’">completion signals</a> from <code><em>Sender</em></code> it checks that for each <code><em>Signature</em></code> in <code><a href="‘#get_completion_signals’">std::execution::get_completion_signals</a>(<em>sender</em>, std::declval&lt;<a href="#env_of_t">std::execution::env_of_t</a>&lt;<em>Receiver</em>&gt;&gt;())</code> the test <code><a href="‘#receiver_of’">std::execution::receiver_of</a>&lt;<em>Receiver</em>, <em>Signature</em>&gt;</code> yields true. To determine if <code><em>Sender</em></code> can be <code><a href="‘#connect’">connect</a></code>ed to <code><em>Receiver</em></code> the concept checks if <code><a href="‘#connect’">connect</a>(std::declval&lt;<em>Sender</em>&gt;(), std::declval&lt;<em>Receiver</em>&gt;)</code> is a valid expression. </p>
</details>
<details >
<summary >
<code>sends_stopped&lt;<em>Sender, Env</em> = std::execution::empty_env&gt;</code></summary>
<p></p>
<p>The concept <code>sends_stopped&lt;<em>Sender, Env</em>&gt;</code> determines if <code><em>Sender</em></code> may send a <code><a href="‘#set_stopped’">stopped</a></code> <a href="‘#completion-signals’">completion signal</a>. To do so, the concepts determines if <code><a href="‘#get_completion_signals’">std::execution::get_completion_signals</a>(<em>sender</em>, <em>env</em>)</code> contains the signatures <code><a href="‘#set_stopped’">std::execution::set_stopped_t</a>()</code>. </p>
</details>
<details >
<summary >
<code>stoppable_token&lt;<em>Token</em>&gt;</code></summary>
<p>A <code>stoppable_token&lt;<em>Token</em>&gt;</code>, e.g., obtained via <code><a href="‘#get-stop-token’">std::execution::get_stop_token</a>(<em>env</em>)</code> is used to support cancellation of asynchronous operations. Using <code><em>token</em>.stop_requested()</code> an active operation can poll whether it was requested to cancel. An inactive operation waiting for a notification can use an object of a specialization of the template <code><em>Token</em>::callback_type</code> to get notified when cancellation is requested.</p>
<p>Required members for <code><em>Token</em></code>:</p>
<ul>
<li><code><em>Token</em>::callback_type&lt;<em>Callback</em>&gt;</code> can be specialized with a <code>std::callable&lt;<em>Callback</em>&gt;</code> type.</li>
<li><code><em>token</em>.stop_requested() const noexcept -&gt; bool</code></li>
<li><code><em>token</em>.stop_possible() const noexcept -&gt; bool</code></li>
<li><code>std::copyable&lt;<em>Token</em>&gt;</code></li>
<li><code>std::equality_comparable&lt;<em>Token</em>&gt;</code></li>
<li><code>std::swappable&lt;<em>Token</em>&gt;</code> <blockquote class="doxtable">
<details >
<summary >
Example: concept use</summary>
<div></div><div><div class="fragment"><div class="line"> {c++}</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::never_stop_token&gt;);</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::stop_token&gt;);</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::inline_stop_token&gt;);</div>
</div><!-- fragment --> </div> </details>
<details >
<summary >
Example: polling</summary>
<blockquote class="doxtable">
<p>This example shows a sketch of using a <code>stoppable_token&lt;<em>Token</em>&gt;</code> to cancel an active operation. The computation in this example is represented as <code>sleep_for</code>.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void compute(std::stoppable_token auto token)</div>
<div class="line">{</div>
<div class="line">    using namespace std::chrono::literals;</div>
<div class="line">    while (not token.stop_requested()) {</div>
<div class="line">         std::this_thread::sleep_for(1s);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </blockquote>
</details>
<details >
<summary >
Example: inactive</summary>
<blockquote class="doxtable">
<p>This example shows how an <code><a href="‘#operation-state’">operation_state</a></code> can use the <code>callback_type</code> together with a <code><em>token</em></code> to get notified when cancellation is requested.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">struct example_state</div>
<div class="line">{</div>
<div class="line">    struct on_cancel</div>
<div class="line">    {</div>
<div class="line">        example_state&amp; state;</div>
<div class="line">        auto operator()() const noexcept {</div>
<div class="line">            this-&gt;state.stop();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    using operation_state_concept = std::execution::operation_state_t;</div>
<div class="line">    using env = std::execution::env_of_t&lt;Receiver&gt;;</div>
<div class="line">    using token = std::execution::stop_callback_of_t&lt;env&gt;;</div>
<div class="line">    using callback = std::execution::stop_callback_of_t&lt;token, on_cancel&gt;;</div>
<div class="line">    std::remove_cvref_t&lt;Receiver&gt; receiver;</div>
<div class="line">    std::optional&lt;callback&gt;       cancel{};</div>
<div class="line">    std::atomic&lt;std::size_t&gt;      outstanding{};</div>
<div class="line">    auto start() &amp; noexcept {</div>
<div class="line">        this-&gt;outstanding += 2u;</div>
<div class="line">        this-&gt;cancel.emplace(</div>
<div class="line">            std::execution::get_stop_token(this-&gt;receiver),</div>
<div class="line">            on_cancel{*this}</div>
<div class="line">        );</div>
<div class="line">        if (this-&gt;outstanding != 2u)</div>
<div class="line">           std::execution::set_stopped(std::move(this-&gt;receiver));</div>
<div class="line">        else {</div>
<div class="line">           register_work(this);</div>
<div class="line">           if (this-&gt;outstanding == 0u)</div>
<div class="line">               std::execution::set_value(std::move(this-&gt;receiver));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    auto stop() {</div>
<div class="line">        unregister_work(this);</div>
<div class="line">        if (--this-&gt;outstanding == 0u)</div>
<div class="line">            std::execution::set_stopped(std::move(this-&gt;receiver));</div>
<div class="line">    }</div>
<div class="line">    auto complete() {</div>
<div class="line">        if (this-&gt;outstanding == 2u) {</div>
<div class="line">            this-&gt;cancel.reset();</div>
<div class="line">            std::execution::set_value(std::move(this-&gt;receiver));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> </blockquote>
</details>
</blockquote>
</li>
</ul>
</details>
<details >
<summary >
<code>unstoppable_token&lt;<em>Token</em>&gt;</code></summary>
<p>The concept <code>unstoppable_token&lt;Token&gt;</code> is modeled by a <code><em>Token</em></code> if <code>stoppable_token&lt;<em>Token</em>&gt;</code> is true and it can statically be determined that both <code><em>token</em>.stop_requested()</code> and <code><em>token</em>.stop_possible()</code> are <code>constexpr</code> epxressions yielding <code>false</code>. This concept is used to avoid extra work when using stop tokens which will never indicate that cancellations are requested. </p><blockquote class="doxtable">
<details >
<summary >
Example</summary>
<p>The concept yields <code>true</code> for the <code><a href="‘#never-stop-token’">std::execution::never_stop_token</a></code>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::never_stop_token&gt;);</div>
<div class="line">static_assert(not std::execution::unstoppable_token&lt;std::execution::stop_token&gt;);</div>
<div class="line">static_assert(not std::execution::unstoppable_token&lt;std::execution::inline_stop_token&gt;);</div>
</div><!-- fragment --> </details>
</blockquote>
</details>
<h2><a class="anchor" id="autotoc_md5"></a>
Queries</h2>
<p>The queries are used to obtain properties associated with an object.</p>
<details >
<summary >
Example defining a query on an environment</summary>
<p>This example shows how to define an environment class which provides a <a href="‘#get-allocator’"><code>get_allocator</code></a> query. The objects stores a <code>std::pmr::memory_resource*</code> and returns a correspondingly initialized <code>std::pmr::polymorphic_allocator&lt;&gt;</code>.</p>
<div class="fragment"><div class="line">struct alloc_env {</div>
<div class="line">   std::pmr::memory_resource res{std::pmr::new_delete_resource()};</div>
<div class="line"> </div>
<div class="line">   auto query(get_allocator_t const&amp;) const noexcept {</div>
<div class="line">       return std::pmr::polymorphic_allocator&lt;&gt;(this-&gt;res);</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --> </details>
<details >
<summary >
<code>forwarding_query(<em>query</em>) -&gt; bool</code></summary>
<p><b>Default</b>: <code>false</code> <br  />
 The expression <code>forwarding_query(<em>query</em>)</code> is a <code>constexpr</code> query used to determine if the query <code><em>query</em></code> should be forwarded when wrapping an environment. The expression is required to be a core constant expression if <code><em>query</em></code> is a core constant expression.</p>
<p>The result of the expression is determined as follows: </p><ol>
<li>
The result is the value of the expression <code><em>query</em>.query(forwarding_query)</code> if this expression is valid and <code>noexcept</code>. </li>
<li>
The result is <code>true</code> if the type of <code><em>query</em></code> is <code>public</code>ly derived from <code>forwarding_query</code>. </li>
<li>
Otherwise the result is <code>false</code>. </li>
</ol>
<blockquote class="doxtable">
<details >
<summary >
Example</summary>
<p>When defining a custom query <code><em>custom</em></code> it is desirable to allow the query getting forwarded. It is necessary to explicit define the result of <code>forwarding_query(<em>custom</em>)</code>. The result can be defined by providing a corresponding <code>query</code> member function. When using this approach the function isn’t allowed to throw, needs to return <code>bool</code>, and needs to be a core constant expression:</p>
<div class="fragment"><div class="line">struct custom_t {</div>
<div class="line">    // ...</div>
<div class="line">    constexpr bool query(forwarding_query_t const&amp;) const noexcept {</div>
<div class="line">        return true;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">inline constexpr custom_t custom{};</div>
</div><!-- fragment --><p>Alternatively, the query can be defined as forwarding by deriving publicly from <code>forwarding_query_t</code>:</p>
<div class="fragment"><div class="line">struct custom_t: forwarding_query_t {</div>
<div class="line">    // ...</div>
<div class="line">};</div>
</div><!-- fragment --> </details>
<blockquote class="doxtable">
<p></p>
</blockquote>
</blockquote>
</details>
<details >
<summary >
<code>get_env(<em>queryable</em>) -&gt; <em>env</em></code></summary>
<p><b>Default</b>: <a href="#empty_env"><code>empty_env</code></a> <br  />
 The expression <code>get_env(<em>queryable</em>)</code> is used to get the environment <code><em>env</em></code> associated with <code><em>queryable</em></code>. To provide a non-default environment for a <code><em>queryable</em></code> a <code>get_env</code> member needs to be defined. If <code><em>queryable</em></code> doesn’t provide the <code>get_env</code> query an object of type <code><a href="‘#empty_env’">empty_env</a></code> is returned. The value of the expression is </p><ol>
<li>
the result of <code>as_const(<em>queryable</em>).get_env()</code> if this expression is valid and <code>noexcept</code>. </li>
<li>
<code>empty_env</code> otherwise. </li>
</ol>
<div> <details >
<summary >
Example</summary>
<p>The example defines an <a href="‘#environment’">environment</a> class <code>env</code> which stores a pointer to the relevant data and is returned as the <a href="‘#environment’">environment</a> for the type <code>queryable</code>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct data { /*...*/ };</div>
<div class="line"> </div>
<div class="line">struct env { data* d; /* ... */ };</div>
<div class="line"> </div>
<div class="line">struct queryable {</div>
<div class="line">    data* d;\</div>
<div class="line">    // ...</div>
<div class="line">    env get_env() const noexcept { return { this-&gt;d }; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the <code>get_env</code> member is both <code>const</code> and <code>noexcept</code>. </p>
</details>
</div> </details>
<details >
<summary >
<code>get_allocator(<em>env</em>) -&gt; <em>allocator</em></code></summary>
<p><b>Default</b>: <em>none</em> <br  />
 The expression <code>get_allocator(<em>env</em>)</code> returns an <code><em>allocator</em></code> for any memory allocations in the respective context. If <code><em>env</em></code> doesn’t support this query any attempt to access it will result in a compilation error. The value of the expression <code>get_allocator(<em>env</em>)</code> is the result of <code>as_const(<em>env</em>).query(get_allocator)</code> if </p><ul>
<li>
the expression is valid; </li>
<li>
the expression is <code>noexcept</code>; </li>
<li>
the result of the expression satisfies <code><em>simple-allocator</em></code>. </li>
</ul>
<p>Otherwise the expression is ill-formed. </p><div> <details >
<summary >
Example</summary>
<p>This example shows how to define an environment class which provides a <a href="‘#get-allocator’"><code>get_allocator</code></a> query. The objects stores a <code>std::pmr::memory_resource*</code> and returns a correspondingly initialized <code>std::pmr::polymorphic_allocator&lt;&gt;</code>.</p>
<div class="fragment"><div class="line">struct alloc_env {</div>
<div class="line">   std::pmr::memory_resource res{std::pmr::new_delete_resource()};</div>
<div class="line"> </div>
<div class="line">   auto query(get_allocator_t const&amp;) const noexcept {</div>
<div class="line">       return std::pmr::polymorphic_allocator&lt;&gt;(this-&gt;res);</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --> </details>
</div> </details>
<details >
<summary >
<code>get_completion_scheduler&lt;&lt;iTtag&gt;(<em>env</em>) -&gt; <em>scheduler</em></code></summary>
<p><b>Default</b>: <em>none</em> <br  />
 The expression <code>get_complet_scheduler&lt;Tag&gt;(<em>env</em>)</code> yields the completion scheduler for the completion signal <code>Tag</code> associated with <code><em>env</em></code>. This query can be used to determine the scheduler a sender <code><em>sender</em></code> completes on for a given completion signal <code>Tag</code> by using <code>get_completion_scheduler&lt;Tag&gt;(get_env(<em>sender</em>))</code>. The value of the expression is equivalent to <code>as_const(<em>env</em>).query(get_completion_scheduler&lt;Tag&gt;)</code> if </p><ol>
<li>
<code>Tag</code> is one of the types <code>set_value_t</code>, <code>set_error_t</code>, or <code>set_stopped_t</code>; </li>
<li>
this expression is valid; </li>
<li>
this expression is <code>noexcept</code>; </li>
<li>
the expression’s type satisfies <code>scheduler</code>. </li>
</ol>
<p>Otherwise the expression is invalid. </p>
</details>
<details >
<summary >
<code>get_completion_signatures(<em>sender</em>, <em>env</em>)</code></summary>
<p>The expression <code>get_completion_signatures(<em>sender</em>, <em>env</em>)</code> returns an object whose type is a specialization of <a href="‘#completion-signatures’"><code>completion_signatures</code></a> defining the possible completion signatures of <code><em>sender</em></code> when connected to a <a href="‘#receiver’"><code><em>receiver</em></code></a> whose &lt;a href=‘::environment'&gt;environment <code>get_env(<em>receiver</em>)</code> is <code><em>env</em></code>. A <a href="‘#sender’"><code>sender</code></a> can define the result of this query either by defining a member function <code>get_completion_signatures</code> or using a type alias <code>completion_signatures</code>.</p>
<p>To determine the result the <code><em>sender</em></code> is first transformed using <code>transform_sender(<em>domain</em>, <em>sender</em>, <em>env</em>)</code> to get <code><em>new-sender</em></code> with type <code><em>New-Sender-Type</em></code>. With that the result type is </p><ol>
<li>
the type of <code><em>new-sender</em>.get_completion_signatures(<em>env</em>)</code> if this expression is valid; </li>
<li>
the type <code>remove_cvref_t&lt;<em>New-Sender-Type</em>&gt;::completion_signatures</code> if this type exists; </li>
<li>
<code>completion_signatures&lt;set_value_t(<em>T</em>), set_error_t(exception_ptr), set_stopped_t()&gt;</code> if <code><em>New-Sender-Type</em></code> is an awaitable type which would yield an object of type <code><em>T</em></code> when it is <code>co_await</code>ed; </li>
<li>
invalid otherwise. </li>
</ol>
<div> <details >
<summary >
Example</summary>
<p>When a <a href="‘#sender’"><code>sender</code></a> doesn’t need to compute the completion signatures based on an <a href="‘#environment’">environment</a> it is easiest to use a the type alias, e.g.: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct sender {</div>
<div class="line">    using sender_concept = std::execution::sender_t;</div>
<div class="line">    using completion_signatures = std::completion_signatures&lt;</div>
<div class="line">        std::execution::set_value_t(int),</div>
<div class="line">        std::execution::set_error_t(std::error_code),</div>
<div class="line">        std::execution::set_stopped()</div>
<div class="line">    &gt;;</div>
<div class="line">    // ...</div>
<div class="line">};</div>
</div><!-- fragment --> </details>
</div> </details>
<details >
<summary >
<code>get_delegation_scheduler(<em>env</em>) -&gt; <em>scheduler</em></code></summary>
<p>The expression <code>get_delegation_scheduler(<em>env</em>)</code> yields the scheduler associated with <code><em>env</em></code> which is used for forward progress delegation. The value of the expression is equivalent to <code>as_const(<em>env</em>).query(get_delegation_scheduler) -&gt; <em>scheduler</em></code> if </p><ol>
<li>
this expression is valid; </li>
<li>
this expression is <code>noexcept</code>; </li>
<li>
the expression’s type satisfies <code>scheduler</code>. </li>
</ol>
<p>Otherwise the expression is invalid. </p>
</details>
<details >
<summary >
<code>get_domain(<em>env</em>) -&gt; <em>domain</em></code></summary>
<p></p>
<p>The expression <code>get_domain(<em>env</em>)</code> yields the domain associated with <code><em>env</em></code>. The value of the expression is equivalent to <code>as_const(<em>env</em>).query(get_domain)</code> if </p><ol>
<li>
this expression is valid; </li>
<li>
this expression is <code>noexcept</code>. </li>
</ol>
<p>Otherwise the expression is invalid. </p>
</details>
<details >
<summary >
<code>get_forward_progress_guarantee(<em>scheduler</em>) -&gt; forward_progress_guarantee</code></summary>
<p>The expression <code>get_forward_progress_guarantee(<em>scheduler</em>)</code> yields the forward progress guarantee of the <em>scheduler</em>’s execution agent. The value of the expression is equivalent to <code>as_const(<em>env</em>).query(get_scheduler)</code> if </p><ol>
<li>
this expression is valid; </li>
<li>
this expression is <code>noexcept</code>; </li>
<li>
the expression’s type is <code>forward_progress_guarantee</code>. </li>
</ol>
<p>Otherwise the expression is invalid. </p>
</details>
<details >
<summary >
<code>get_scheduler(<em>env</em>) -&gt; <em>scheduler</em></code></summary>
<p>The expression <code>get_scheduler(<em>env</em>)</code> yields the scheduler associated with <code><em>env</em></code>. The value of the expression is equivalent to <code>as_const(<em>env</em>).query(get_scheduler)</code> if </p><ol>
<li>
this expression is valid; </li>
<li>
this expression is <code>noexcept</code>; </li>
<li>
the expression’s type satisfies <code>scheduler</code>. </li>
</ol>
<p>Otherwise the expression is invalid. </p>
</details>
<details >
<summary >
<code>get_stop_token(<em>env</em>) -&gt; <em>stoppable_token</em></code></summary>
<p>The expression <code>get_stop_token(<em>env</em>)</code> yields the stop token associated with <code><em>env</em></code>. The value is the result of the expression <code>as_const(<em>env</em>).query(get_stop_token)</code> if </p><ul>
<li>
the expression is valid; </li>
<li>
the expression is <code>noexcept</code>; </li>
<li>
the expression satisfies <code>stoppable_token</code>. </li>
</ul>
<p>Otherwise the value is <code>never_stop_token{}</code>. </p>
</details>
<h2><a class="anchor" id="autotoc_md6"></a>
Customization Point Objects</h2>
<details >
<summary >
<code>connect(<em>sender</em>, <em>receiver</em>) -&gt; <em>operation_state</em></code></summary>
<p>The expression <code>connect(<em>sender</em>, <em>receiver</em>)</code> combines <code><em>sender</em></code> and <code><em>receiver</em></code> into an operation state <code><em>state</em></code>. When this <code><em>state</em></code> gets started using <code>start(<em>state</em>)</code> the operation represented by <code><em>sender</em></code> gets started and reports its completion to <code><em>receiver</em></code> or an object copied or moved from <code><em>receiver</em></code>. While the operation state <code><em>state</em></code> isn’t started it can be destroyed but once it got started it needs to stay valid until one of the completion signals is called on <code><em>receiver</em></code>. </p>
</details>
<details >
<summary >
<code>set_error(<em>receiver</em>, <em>error</em>) noexcept -&gt; void</code></summary>
<p>The expression <code>set_error(<em>receiver</em>, <em>error</em>)</code> invokes the <code>set_error</code> completion signal on <code><em>receiver</em></code> with the argument <code><em>error</em></code>, i.e., it invokes <code><em>receiver</em>.set_error(<em>error</em>)</code>. </p>
</details>
<details >
<summary >
<code>set_stopped(<em>receiver</em>) noexcept -&gt; void</code></summary>
<p>The expression <code>set_stopped(<em>receiver</em>)</code> invokes the <code>set_stopped</code> completion signal on <code><em>receiver</em></code>, i.e., it invokes <code><em>receiver</em>.set_stopped()</code>. </p>
</details>
<details >
<summary >
<code>set_value(<em>receiver</em>, <em>value</em>...) noexcept -&gt; void</code></summary>
<p>The expression <code>set_value(<em>receiver</em>, <em>value</em>...)</code> invokes the <code>set_value</code> completion signal on <code><em>receiver</em></code> with the argument(s) <code><em>value</em>...</code>, i.e., it invokes <code><em>receiver</em>.set_value(<em>value</em>...)</code>. </p>
</details>
<details >
<summary >
<code>start(<em>state</em>) noexcept -&gt; void</code></summary>
<p>The expression <code>start(<em>state</em>)</code> starts the execution of the <code>operation_state</code> object <code><em>state</em></code>. Once this expression started executing the object <code><em>state</em></code> is required to stay valid at least until one of the completion signals of <code><em>state</em></code>’s <code>receiver</code> is invoked. Once started exactly one of the completion signals is eventually called. </p>
</details>
<h2><a class="anchor" id="autotoc_md7"></a>
Senders</h2>
<h3><a class="anchor" id="autotoc_md8"></a>
Sender Factories</h3>
<p>Sender factories create a sender which forms the start of a graph of lazy work items.</p>
<details >
<summary >
<code>just(<em>value...</em>) -&gt; <em>sender-of</em>&lt;set_value_t(<em>Value...</em>)&gt;</code></summary>
<p>The expression <code>just(<em>value...</em>)</code> creates a sender which sends <code><em>value...</em></code> on the <code>set_value</code> (success) channel when started (note that <code><em>value...</em></code> can be empty).</p>
<p><b>Completions</b> </p><ul>
<li>
<code>set_value_t(decltype(<em>value</em>)...)</code> </li>
</ul>
</details>
<details >
<summary >
<code>just_error(<em>error</em>) -&gt; <em>sender-of</em>&lt;set_error_t(<em>Error</em>)&gt;</code></summary>
<p>The expression <code>just_error(<em>error</em>)</code> creates a sender which sends <code><em>error</em></code> on the <code>set_error</code> (failure) channel when started.</p>
<p><b>Completions</b> </p><ul>
<li>
<code>set_error_t(decltype(<em>error</em>))</code> </li>
</ul>
</details>
<details >
<summary >
<code>just_stopped() -&gt; <em>sender-of</em>&lt;set_stopped_t()&gt;</code></summary>
<p>The expression <code>just_stopped()</code> creates a sender which sends a completion on the <code>set_stopped</code> (cancellation) channel when started.</p>
<p><b>Completions</b> </p><ul>
<li>
<code>set_stopped_t()</code> </li>
</ul>
</details>
<details >
<summary >
<code>read_env(<em>query</em>) -&gt; <em>sender-of</em>&lt;set_value_t(<em>query-result</em>)&gt;</code></summary>
<p>The expression <code>read_env(<em>query</em>)</code> creates a sender which sends the result of querying <code><em>query</em></code> the environment of the <code><em>receiver</em></code> it gets connected to on the <code>set_value</code> channel when started. Put differently, it calls <code>set_value(move(<em>receiver</em>), <em>query</em>(get_env(<em>receiver</em>)))</code>. For example, in a coroutine it may be useful to extra the stop token associated with the coroutine which can be done using <code>read_env</code>:</p>
<div class="fragment"><div class="line"> {c++\}</div>
<div class="line">auto token = co_await read_env(get_stop_token);</div>
</div><!-- fragment --><p><b>Completions</b> </p><ul>
<li>
<code>set_value_t(decltype(<em>query</em>(get_env(<em>receiver</em>))))</code> </li>
</ul>
</details>
<details >
<summary >
<code>schedule(<em>scheduler</em>) -&gt; <em>sender-of</em>&lt;set_value_t()&gt;</code></summary>
<p>The expression <code>schedule(<em>scheduler</em>)</code> creates a sender which upon success completes on the <code>set_value</code> channel without any arguments running on the execution context associated with <code><em>scheduler</em></code>. Depending on the scheduler it is possible that the sender can complete with an error if the scheduling fails or using <code>set_stopped()</code> if the operation gets cancelled before it is successful.</p>
<p><b>Completions</b> </p><ul>
<li>
<code>set_value_t()</code> upon success </li>
<li>
<code>set_error_t(<em>Error</em>)</code> upon failure if <code><em>scheduler</em></code> may fail </li>
<li>
<code>set_stopped_t()</code> upon cancellation if <code><em>scheduler</em></code> supports cancellation </li>
</ul>
</details>
<h3><a class="anchor" id="autotoc_md9"></a>
Sender Adaptors</h3>
<p>The sender adaptors take one or more senders and adapt their respective behavior to complete with a corresponding result. The description uses the informal function <code><em>completions-of</em>(<em>sender</em>)</code> to represent the completion signatures which <code><em>sender</em></code> produces. Also, completion signatures are combined using <code>+</code>: the result is the deduplicated set of the combined completion signatures.</p>
<details >
<summary >
<code>bulk</code></summary>
<p></p>
</details>
<details >
<summary >
<code>continues_on(<em>sender</em>, <em>scheduler</em>) -&gt; <em>sender-of</em>&lt;<em>completions-of</em>(<em>sender</em>) + <em>completions-of</em>(schedule(<em>scheduler</em>))&gt;</code></summary>
<p>The expression <code>continues_on(<em>sender</em>, <em>scheduler</em>)</code> creates a sender <code><em>cs</em></code> which starts <code><em>sender</em></code> when started. The results from <code><em>sender</em></code> are stored. Once that is <code><em>cs</em></code> creates a sender using <code>schedule(<em>scheduler</em>)</code> and completes itself on the execution once that sender completes.</p>
<p><b>Completions</b> </p><ul>
<li>
<code><em>completions-of</em>(<em>sender</em>)</code> </li>
<li>
<code><em>completions-of</em>(schedule(<em>scheduler</em>))</code> </li>
</ul>
</details>
<details >
<summary >
<code>into_variant(<em>sender</em>) -&gt; <em>sender-of</em>&lt;set_value_t(std::variant&lt;<em>Tuple</em>...&gt;)&gt;</code></summary>
<p>The expression <code>into_variant(<em>sender</em>)</code> creates a sender which transforms the results of possibly multiple <code>set_value</code> completions of <code><em>sender</em></code> into one <code>set_value</code> completion representing the different upstream results as different options of a <code>variant&lt;<em>Tuple</em>...&gt;</code> where each <code><em>Tuple</em></code> is a <code>tuple</code> of values initialized with the respective arguments passed to <code>set_value</code>. The order of options in the <code>variant</code> isn’t specified. </p>
</details>
<details >
<summary >
<code>let_error(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<details >
<summary >
<code>let_stopped(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<details >
<summary >
<code>let_value(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<details >
<summary >
<code>on</code></summary>
<p></p>
</details>
<details >
<summary >
<code>schedule_from(<em>scheduler</em>, <em>sender</em>) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<details >
<summary >
<code>split</code></summary>
<p></p>
</details>
<details >
<summary >
<code>starts_on(<em>scheduler</em>, <em>sender</em>) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<details >
<summary >
<code>stopped_as_error</code></summary>
<p></p>
</details>
<details >
<summary >
<code>stopped_as_optional</code></summary>
<p></p>
</details>
<details >
<summary >
<code>then(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<details >
<summary >
<code>upon_error(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<details >
<summary >
<code>upon_stopped(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<details >
<summary >
<code>when_all(<em>sender</em>...) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<details >
<summary >
<code>when_all_with_variant(<em>sender</em>...) -&gt; <em>sender</em></code></summary>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md10"></a>
Sender Consumers</h3>
<ul>
<li><code>sync_wait(<em>sender</em>) -&gt; std::optional&lt;std::tuple&lt;T...&gt;&gt;</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
Helpers</h2>
<ul>
<li><code>as_awaitable</code></li>
<li><code>with_awaitable_sender</code></li>
<li><code>apply_sender</code></li>
<li><code>completion_signatures</code></li>
<li><code>completion_signatures_t</code></li>
<li><code>connect_result_t</code></li>
<li><code>default_domain</code></li>
<li><code>empty_env</code></li>
<li><code>env_of_t</code></li>
<li><code>error_types_of_t</code></li>
<li><code>fwd_env</code></li>
<li><code>operation_state_t</code></li>
<li><code>receiver_t</code></li>
<li><code>run_loop</code></li>
<li><code>scheduler_t</code></li>
<li><code>schedule_result_t</code></li>
<li><code>sender_adaptor_closure</code></li>
<li><code>sender_t</code></li>
<li><code>stop_token_of_t</code></li>
<li><code>tag_of_t</code></li>
<li><code>transform_sender</code></li>
<li><code>transform_completion_signatures</code></li>
<li><code>transform_completion_signatures_of</code></li>
<li><code>value_types_of_t</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
Stop Token</h2>
<ul>
<li><code>never_stop_token</code></li>
<li><code>stop_token</code></li>
<li><code>inplace_stop_token</code> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
